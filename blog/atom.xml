<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://microsoft.github.io/FLAML/blog</id>
    <title>FLAML Blog</title>
    <updated>2023-05-18T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://microsoft.github.io/FLAML/blog"/>
    <subtitle>FLAML Blog</subtitle>
    <icon>https://microsoft.github.io/FLAML/img/flaml_logo.ico</icon>
    <entry>
        <title type="html"><![CDATA[Achieve More, Pay Less - Use GPT-4 Smartly]]></title>
        <id>Achieve More, Pay Less - Use GPT-4 Smartly</id>
        <link href="https://microsoft.github.io/FLAML/blog/2023/05/18/GPT-adaptive-humaneval"/>
        <updated>2023-05-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[An adaptive way of using GPT-3.5 and GPT-4 outperforms GPT-4 in both coding success rate and inference cost]]></summary>
        <content type="html"><![CDATA[<p><img src="img/humaneval.png" alt="An adaptive way of using GPT-3.5 and GPT-4 outperforms GPT-4 in both coding success rate and inference cost"/></p><p><strong>TL;DR:</strong></p><ul><li><strong>A case study using the HumanEval benchmark shows that an adaptive way of using multiple GPT models can achieve both much higher accuracy (from 68% to 90%) and lower inference cost (by 18%) than using GPT-4 for coding.</strong></li></ul><p>GPT-4 is a big upgrade of foundation model capability, e.g., in code and math, accompanied by a much higher (more than 100x) price per token to use over GPT-3.5-Turbo. On a code completion benchmark, <a href="https://huggingface.co/datasets/openai_humaneval">HumanEval</a>, developed by OpenAI, GPT-4 can successfully solve 68% tasks while GPT-3.5-Turbo does 46%. It is possible to increase the success rate of GPT-4 further by generating multiple responses or making multiple calls. However, that will further increase the cost, which is already nearly 20 times of using GPT-3.5-Turbo and with more restricted API call rate limit. Can we achieve more with less?</p><p>In this blog post, we will explore a creative, adaptive way of using GPT models which leads to a big leap forward.</p><h2>Observations</h2><ul><li>GPT-3.5-Turbo can alrady solve 40%-50% tasks. For these tasks if we never use GPT-4, we can save nearly 40-50% cost.</li><li>If we use the saved cost to generate more responses with GPT-4 for the remaining unsolved tasks, it is possible to solve some more of them while keeping the amortized cost down.</li></ul><p>The obstacle of leveraging these observations is that we do not know <em>a priori</em> which tasks can be solved by the cheaper model, which tasks can be solved by the expensive model, and which tasks can be solved by paying even more to the expensive model.</p><p>To overcome that obstacle, one may want to predict which task requires what model to solve and how many responses are required for each task. Let&#x27;s look at one example code completion task:</p><pre><code class="language-python">def vowels_count(s):
    &quot;&quot;&quot;Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are &#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;. Here, &#x27;y&#x27; is also a
    vowel, but only when it is at the end of the given word.

    Example:
    &gt;&gt;&gt; vowels_count(&quot;abcde&quot;)
    2
    &gt;&gt;&gt; vowels_count(&quot;ACEDY&quot;)
    3
    &quot;&quot;&quot;
</code></pre><p>Can we predict whether GPT-3.5-Turbo can solve this task or do we need to use GPT-4? My first guess is that GPT-3.5-Turbo can get it right because the instruction is fairly straightforward. Yet, it turns out that GPT-3.5-Turbo does not consistently get it right, if we only give it one chance. It&#x27;s not obvious (but an interesting research question!) how to predict the performance without actually trying.</p><p>What else can we do? We notice that:
<strong>It&#x27;s &quot;easier&quot; to verify a given solution than finding a correct solution from scratch.</strong></p><p>Some simple example test cases are provided in the docstr. If we already have a response generated by a model, we can use those test cases to filter wrong implementations, and either use a more powerful model or generate more responses, until the result passes the example test cases. Moreover, this step can be automated by asking GPT-3.5-Turbo to generate assertion statements from the examples given in the docstr (a simpler task where we can place our bet) and executing the code.</p><h2>Solution</h2><p>Combining these observations, we can design a solution with two intuitive ideas:</p><ul><li>Make use of auto-generated feedback, i.e., code execution results, to filter responses.</li><li>Try inference configurations one by one, until one response can pass the filter.</li></ul><p><img src="img/design.png" alt="Design"/></p><p>This solution works adaptively without knowing or predicting which task fits which configuration. It simply tries multiple configurations one by one, starting from the cheapest configuration. Note that one configuration can generate multiple responses (by setting the inference parameter n larger than 1). And different configurations can use the same model and different inference parameters such as n and temperature. Only one response is returned and evaluated per task.</p><p>An implementation of this solution is provided in <a href="/docs/reference/autogen/code_utils#implement">flaml.autogen</a>. It uses the following sequence of configurations:</p><ol><li>GPT-3.5-Turbo, n=1, temperature=0</li><li>GPT-3.5-Turbo, n=7, temperature=1, stop=<!-- -->[&quot;\nclass&quot;, &quot;\ndef&quot;, &quot;\nif&quot;, &quot;\nprint&quot;]</li><li>GPT-4, n=1, temperature=0</li><li>GPT-4, n=2, temperature=1, stop=<!-- -->[&quot;\nclass&quot;, &quot;\ndef&quot;, &quot;\nif&quot;, &quot;\nprint&quot;]</li><li>GPT-4, n=1, temperature=1, stop=<!-- -->[&quot;\nclass&quot;, &quot;\ndef&quot;, &quot;\nif&quot;, &quot;\nprint&quot;]</li></ol><h2>Experiment Results</h2><p>The first figure in this blog post shows the success rate and average inference cost of the adaptive solution compared with default GPT-4.
The inference cost includes the cost for generating the assertions in our solution. The generated assertions are not always correct, and programs that pass/fail the generated assertions are not always right/wrong. Despite of that, the adaptive solution can increase the success rate (referred to as pass@1 in the literature) from 68% to 90%, while reducing the cost by 18%.</p><p>Here are a few examples of function definitions which are solved by different configurations in the portfolio.</p><ol><li>Solved by GPT-3.5-Turbo, n=1, temperature=0</li></ol><pre><code class="language-python">def compare(game,guess):
    &quot;&quot;&quot;I think we all remember that feeling when the result of some long-awaited
    event is finally known. The feelings and thoughts you have at that moment are
    definitely worth noting down and comparing.
    Your task is to determine if a person correctly guessed the results of a number of matches.
    You are given two arrays of scores and guesses of equal length, where each index shows a match.
    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,
    the value is 0, and if not, the value is the absolute difference between the guess and the score.


    example:

    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -&gt; [0,0,0,0,3,3]
    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -&gt; [4,4,1,0,0,6]
    &quot;&quot;&quot;
</code></pre><ol start="2"><li>Solved by GPT-3.5-Turbo, n=7, temperature=1, stop=<!-- -->[&quot;\nclass&quot;, &quot;\ndef&quot;, &quot;\nif&quot;, &quot;\nprint&quot;]<!-- -->: the <code>vowels_count</code> function presented earlier.</li><li>Solved by GPT-4, n=1, temperature=0:</li></ol><pre><code class="language-python">def string_xor(a: str, b: str) -&gt; str:
    &quot;&quot;&quot; Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.
    &gt;&gt;&gt; string_xor(&#x27;010&#x27;, &#x27;110&#x27;)
    &#x27;100&#x27;
    &quot;&quot;&quot;
</code></pre><ol start="4"><li>Solved by GPT-4, n=2, temperature=1, stop=<!-- -->[&quot;\nclass&quot;, &quot;\ndef&quot;, &quot;\nif&quot;, &quot;\nprint&quot;]<!-- -->:</li></ol><pre><code class="language-python">def is_palindrome(string: str) -&gt; bool:
    &quot;&quot;&quot; Test if given string is a palindrome &quot;&quot;&quot;
    return string == string[::-1]


def make_palindrome(string: str) -&gt; str:
    &quot;&quot;&quot; Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    &gt;&gt;&gt; make_palindrome(&#x27;&#x27;)
    &#x27;&#x27;
    &gt;&gt;&gt; make_palindrome(&#x27;cat&#x27;)
    &#x27;catac&#x27;
    &gt;&gt;&gt; make_palindrome(&#x27;cata&#x27;)
    &#x27;catac&#x27;
    &quot;&quot;&quot;
</code></pre><ol start="5"><li>Solved by GPT-4, n=1, temperature=1, stop=<!-- -->[&quot;\nclass&quot;, &quot;\ndef&quot;, &quot;\nif&quot;, &quot;\nprint&quot;]<!-- -->:</li></ol><pre><code class="language-python">def sort_array(arr):
    &quot;&quot;&quot;
    In this Kata, you have to sort an array of non-negative integers according to
    number of ones in their binary representation in ascending order.
    For similar number of ones, sort based on decimal value.

    It must be implemented like this:
    &gt;&gt;&gt; sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    &gt;&gt;&gt; sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    &gt;&gt;&gt; sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    &quot;&quot;&quot;
</code></pre><p>The last problem is an example with wrong example test cases in the original definition. It misleads the adaptive solution because a correct implementation is regarded as wrong and more trials are made. The last configuration in the sequence returns the right implementation, even though it does not pass the auto-generated assertions. This example demonstrates that:</p><ul><li>Our adaptive solution has a certain degree of fault tolerance.</li><li>The success rate and inference cost for the adaptive solution can be further improved if correct example test cases are used.</li></ul><p>It is worth noting that the reduced inference cost is the amortized cost over all the tasks. For each individual task, the cost can be either larger or smaller than directly using GPT-4. This is the nature of the adaptive solution: The cost is in general larger for difficult tasks than that for easy tasks.</p><p>An example notebook to run this experiment can be found at: <a href="https://github.com/microsoft/FLAML/blob/v1.2.1/notebook/research/autogen_code.ipynb">https://github.com/microsoft/FLAML/blob/v1.2.1/notebook/research/autogen_code.ipynb</a></p><h2>Discussion</h2><p>Our solution is quite simple to <a href="/docs/reference/autogen/code_utils#implement">implement</a> using a generic interface offered in <a href="/docs/Use-Cases/Auto-Generation#logic-error"><code>flaml.autogen</code></a>, yet the result is quite encouraging.</p><p>While the specific way of generating assertions is application-specific, the main ideas are general in LLM operations:</p><ul><li>Generate multiple responses to select - especially useful when selecting a good response is relatively easier than generating a good response at one shot.</li><li>Consider multiple configurations to generate responses - especially useful when:<ul><li>Model and other inference parameter choice affect the utility-cost tradeoff; or</li><li>Different configurations have complementary effect.</li></ul></li></ul><p>A <a href="/blog/2023/04/21/LLM-tuning-math">previous blog post</a> provides evidence that these ideas are relevant in solving math problems too.
<code>flaml.autogen</code> uses a technique <a href="https://arxiv.org/abs/2303.04673">EcoOptiGen</a> to support inference parameter tuning and model selection.</p><p>There are many directions of extensions in research and development:</p><ul><li>Generalize the way to provide feedback.</li><li>Automate the process of optimizing the configurations.</li><li>Build adaptive agents for different applications.</li></ul><p><em>Do you find this approach applicable to your use case? Do you have any other challenge to share about LLM applications? Do you like to see more support or research of LLM optimization or automation? Please join our <a href="https://discord.gg/Cppx2vSPVP">Discord</a> server for discussion.</em></p><h2>For Further Reading</h2><ul><li><a href="/docs/Use-Cases/Auto-Generation">Documentation</a> about <code>flaml.autogen</code> and <a href="https://arxiv.org/abs/2303.04673">Research paper</a>.</li><li><a href="/blog/2023/04/21/LLM-tuning-math">Blog post</a> about a related study for math.</li></ul>]]></content>
        <author>
            <name>Chi Wang</name>
            <uri>https://www.linkedin.com/in/chi-wang-49b15b16/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Surpassing 1 Million Downloads - A Retrospective and a Look into the Future]]></title>
        <id>Surpassing 1 Million Downloads - A Retrospective and a Look into the Future</id>
        <link href="https://microsoft.github.io/FLAML/blog/2023/05/07/1M-milestone"/>
        <updated>2023-05-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[TL;DR:]]></summary>
        <content type="html"><![CDATA[<p><strong>TL;DR:</strong></p><ul><li><strong>Celebrating FLAML&#x27;s milestone: 1 million downloads</strong></li><li><strong>Introducing Large Language Model (LLM) support in the upcoming FLAML v2</strong></li></ul><p>This week, FLAML has reached a significant milestone: 1 million downloads. Originating as an intern research project within Microsoft Research, FLAML has grown into an open-source library used widely across the industry and supported by an active community.
As we celebrate this milestone, we want to recognize the passionate contributors and users who have played an essential role in molding FLAML into the flourishing project it is today. Our heartfelt gratitude goes out to each of you for your unwavering support, constructive feedback, and innovative contributions that have driven FLAML to new heights.
A big shoutout to our industrial collaborators from Azure Core, Azure Machine Learning, Azure Synapse Analytics, Microsoft 365, ML.NET, Vowpal Wabbit, Anyscale, Databricks, and Wise; and academic collaborators from MIT, Penn State University, Stevens Institute of Technology, Tel Aviv University, Texas A &amp; M University, University of Manchester, University of Washington, and The Chinese University of Hong Kong etc.</p><p>We&#x27;d also like to take the opportunity to reflect on FLAML&#x27;s past achievements and its future roadmap, with a particular focus on large language models (LLM) and LLMOps.</p><h2>FLAML&#x27;s Journey: Past Achievements and Milestones</h2><h3>Bring AutoML to One&#x27;s Fingertips</h3><p>FLAML offers an off-the-shelf AutoML solution that enables users to quickly discover high-quality models or configurations for common ML/AI tasks. By automatically selecting models and hyperparameters for training or inference, FLAML saves users time and effort. FLAML has significantly reduced development time for developers and data scientists alike, while also providing a convenient way to integrate new algorithms into the pipeline, enabling easy extensions and large-scale parallel tuning. These features make FLAML a valuable tool in R&amp;D efforts for many enterprise users.
FLAML is capable of handling a variety of common ML tasks, such as <a href="https://microsoft.github.io/FLAML/docs/Examples/AutoML-Classification">classification</a>, <a href="https://microsoft.github.io/FLAML/docs/Examples/AutoML-Regression">regression</a>, <a href="https://microsoft.github.io/FLAML/docs/Examples/AutoML-Time%20series%20forecast">time series forecasting</a>, <a href="https://microsoft.github.io/FLAML/docs/Examples/AutoML-Rank">NLP tasks</a>, and <a href="https://microsoft.github.io/FLAML/docs/Use-Cases/Auto-Generation">generative tasks</a>, providing a comprehensive solution for various applications.</p><h3>Speed and Efficiency: The FLAML Advantage</h3><p>What sets FLAML apart from other AutoML libraries is its exceptional efficiency, thanks to the economical and efficient hyperparameter optimization and model selection methods developed in our <a href="https://microsoft.github.io/FLAML/docs/Research">research</a>. FLAML is also capable of handling large search spaces with heterogeneous evaluation costs, complex constraints, guidance, and early stopping. The <a href="https://microsoft.github.io/FLAML/docs/Use-Cases/Zero-Shot-AutoML">zero-shot AutoML</a> option further reduces the cost of AutoML, making FLAML an even more attractive solution for a wide range of applications with low resources.</p><h3>Easy Customization and Extensibility</h3><p>FLAML is designed for easy extensibility and customization, allowing users to add custom learners, metrics, search space, etc. For example, the support of hierarchical search spaces allows one to first choose an ML learner and then sampling from the hyperparameter space specific to that learner. The level of customization ranges from minimal (providing only training data and task type as input) to full (tuning a user-defined function). This flexibility and support for easy customization have led to FLAML&#x27;s adoption in various domains, including security, finance, marketing, engineering, supply chain, insurance, and healthcare, delivering highly accurate results.</p><h2>Embracing Large Language Models in FLAML v2</h2><p>As large language models continue to reshape the AI ecosystem, FLAML is poised to adapt and grow alongside these advancements. Recognizing the importance of large language models, we have recently incorporated an autogen package into FLAML, and are committed to focusing our collective efforts on addressing the unique challenges that arise in LLMOps (Large Language Model Operations).</p><p>In its current iteration, FLAML offers support for model selection and inference parameter tuning for large language models. We are actively working on the development of new features, such as low-level inference API with caching, templating, filtering, and higher-level components like LLM-based coding and interactive agents, to enable more effective and economical usage of LLM.</p><p>We are eagerly preparing for the launch of FLAML v2, where we will place special emphasis on incorporating and enhancing features specifically tailored for large language models (LLMs), further expanding FLAML&#x27;s capabilities.
We invite contributions from anyone interested in this topic and look forward to collaborating with the community as we shape the future of FLAML and LLMOps together.</p><h2>For Further Reading</h2><ul><li><a href="/docs/Use-Cases/Auto-Generation">Documentation about <code>flaml.autogen</code></a></li><li><a href="https://github.com/microsoft/FLAML/blob/main/notebook/autogen_chatgpt_gpt4.ipynb">Code Example: Tune chatGPT for Math Problem Solving with FLAML</a></li></ul><p><em>Do you have any experience to share about LLM applications? Do you like to see more support or research of LLMOps? Please join our <a href="https://discord.gg/Cppx2vSPVP">Discord</a> server for discussion.</em></p>]]></content>
        <author>
            <name>Qingyun Wu</name>
            <uri>https://qingyun-wu.github.io/</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Does Model and Inference Parameter Matter in LLM Applications? - A Case Study for MATH]]></title>
        <id>Does Model and Inference Parameter Matter in LLM Applications? - A Case Study for MATH</id>
        <link href="https://microsoft.github.io/FLAML/blog/2023/04/21/LLM-tuning-math"/>
        <updated>2023-04-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[level 2 algebra]]></summary>
        <content type="html"><![CDATA[<p><img src="img/level2algebra.png" alt="level 2 algebra"/></p><p><strong>TL;DR:</strong></p><ul><li><strong>Just by tuning the inference parameters like model, number of responses, temperature etc. without changing any model weights or prompt, the baseline accuracy of untuned gpt-4 can be improved by 20% in high school math competition problems.</strong></li><li><strong>For easy problems, the tuned gpt-3.5-turbo model vastly outperformed untuned gpt-4 in accuracy (e.g., 90% vs. 70%) and cost efficiency. For hard problems, the tuned gpt-4 is much more accurate (e.g., 35% vs. 20%) and less expensive than untuned gpt-4.</strong></li><li><strong>FLAML can help with model selection, parameter tuning, and cost-saving in LLM applications.</strong></li></ul><p>Large language models (LLMs) are powerful tools that can generate natural language texts for various applications, such as chatbots, summarization, translation, and more. GPT-4 is currently the state of the art LLM in the world. Is model selection irrelevant? What about inference parameters?</p><p>In this blog post, we will explore how model and inference parameter matter in LLM applications, using a case study for <a href="https://datasets-benchmarks-proceedings.neurips.cc/paper/2021/hash/be83ab3ecd0db773eb2dc1b0a17836a1-Abstract-round2.html">MATH</a>, a benchmark for evaluating LLMs on advanced mathematical problem solving. MATH consists of 12K math competition problems from AMC-10, AMC-12 and AIME. Each problem is accompanied by a step-by-step solution.</p><p>We will use the new subpackage <a href="docs/Use-Cases/Auto-Generation"><code>flaml.autogen</code></a> to automatically find the best model and inference parameter for LLMs on a given task and dataset given an inference budget, using a novel low-cost search &amp; pruning strategy. FLAML currently supports all the LLMs from OpenAI, such as GPT-3.5 and GPT-4.</p><p>We will use FLAML to perform model selection and inference parameter tuning. Then we compare the performance and inference cost on solving algebra problems with the untuned gpt-4. We will also analyze how different difficulty levels affect the results.</p><h2>Experiment Setup</h2><p>We use FLAML to select between the following models with a target inference budget $0.02 per instance:</p><ul><li>gpt-3.5-turbo, a relatively cheap model that powers the popular ChatGPT app</li><li>gpt-4, the state of the art LLM that costs more than 100 times of gpt-3.5-turbo</li></ul><p>We adapt the models using 20 examples in the train set, using the problem statement as the input and generating the solution as the output. We use the following inference parameters:</p><ul><li>temperature: The parameter that controls the randomness of the output text. A higher temperature means more diversity but less coherence. We search for the optimal temperature in the range of <!-- -->[0, 1]<!-- -->.</li><li>top_p: The parameter that controls the probability mass of the output tokens. Only tokens with a cumulative probability less than or equal to top-p are considered. A lower top-p means more diversity but less coherence. We search for the optimal top-p in the range of <!-- -->[0, 1]<!-- -->.</li><li>max_tokens: The maximum number of tokens that can be generated for each output. We search for the optimal max length in the range of <!-- -->[50, 1000]<!-- -->.</li><li>n: The number of responses to generate. We search for the optimal n in the range of <!-- -->[1, 100]<!-- -->.</li><li>prompt: We use the template: &quot;{problem} Solve the problem carefully. Simplify your answer as much as possible. Put the final answer in <!-- -->\<!-- -->boxed{{}}.&quot; where {problem} will be replaced by the math problem instance.</li></ul><p>In this experiment, when n &gt; 1, we find the answer with highest votes among all the responses and then select it as the final answer to compare with the ground truth. For example, if n = 5 and 3 of the responses contain a final answer 301 while 2 of the responses contain a final answer 159, we choose 301 as the final answer. This can help with resolving potential errors due to randomness. We use the average accuracy and average inference cost as the metric to evaluate the performance over a dataset. The inference cost of a particular instance is measured by the price per 1K tokens and the number of tokens consumed.</p><h2>Experiment Results</h2><p>The first figure in this blog post shows the average accuracy and average inference cost of each configuration on the level 2 Algebra test set.</p><p>Surprisingly, the tuned gpt-3.5-turbo model is selected as a better model and it vastly outperforms untuned gpt-4 in accuracy (92% vs. 70%) with equal or 2.5 times higher inference budget.
The same observation can be obtained on the level 3 Algebra test set.</p><p><img src="img/level3algebra.png" alt="level 3 algebra"/></p><p>However, the selected model changes on level 4 Algebra.</p><p><img src="img/level4algebra.png" alt="level 4 algebra"/></p><p>This time gpt-4 is selected as the best model. The tuned gpt-4 achieves much higher accuracy (56% vs. 44%) and lower cost than the untuned gpt-4.
On level 5 the result is similar.</p><p><img src="img/level5algebra.png" alt="level 5 algebra"/></p><p>We can see that FLAML has found different optimal model and inference parameters for each subset of a particular level, which shows that these parameters matter in cost-sensitive LLM applications and need to be carefully tuned or adapted.</p><p>An example notebook to run these experiments can be found at: <a href="https://github.com/microsoft/FLAML/blob/v1.2.1/notebook/autogen_chatgpt.ipynb">https://github.com/microsoft/FLAML/blob/v1.2.1/notebook/autogen_chatgpt.ipynb</a></p><h2>Analysis and Discussion</h2><p>While gpt-3.5-turbo demonstrates competitive accuracy with voted answers in relatively easy algebra problems under the same inference budget, gpt-4 is a better choice for the most difficult problems. In general, through parameter tuning and model selection, we can identify the opportunity to save the expensive model for more challenging tasks, and improve the overall effectiveness of a budget-constrained system.</p><p>There are many other alternative ways of solving math problems, which we have not covered in this blog post. When there are choices beyond the inference parameters, they can be generally tuned via <a href="docs/Use-Cases/Tune-User-Defined-Function"><code>flaml.tune</code></a>.</p><p>The need for model selection, parameter tuning and cost saving is not specific to the math problems. The <a href="https://github.com/Significant-Gravitas/Auto-GPT">Auto-GPT</a> project is an example where high cost can easily prevent a generic complex task to be accomplished as it needs many LLM inference calls.</p><h2>For Further Reading</h2><ul><li><a href="https://arxiv.org/abs/2303.04673">Research paper about the tuning technique</a></li><li><a href="/docs/Use-Cases/Auto-Generation">Documentation about <code>flaml.autogen</code></a></li></ul><p><em>Do you have any experience to share about LLM applications? Do you like to see more support or research of LLM optimization or automation? Please join our <a href="https://discord.gg/Cppx2vSPVP">Discord</a> server for discussion.</em></p>]]></content>
        <author>
            <name>Chi Wang</name>
            <uri>https://www.linkedin.com/in/chi-wang-49b15b16/</uri>
        </author>
    </entry>
</feed>