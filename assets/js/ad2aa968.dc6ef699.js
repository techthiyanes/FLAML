"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7026],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,f=p["".concat(l,".").concat(d)]||p[d]||m[d]||i;return n?a.createElement(f,o(o({ref:t},u),{},{components:n})):a.createElement(f,o({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8957:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={},l="Getting Started",c={unversionedId:"Getting-Started",id:"Getting-Started",isDocsHomePage:!1,title:"Getting Started",description:"FLAML is a lightweight Python library that finds accurate machine",source:"@site/docs/Getting-Started.md",sourceDirName:".",slug:"/Getting-Started",permalink:"/FLAML/docs/Getting-Started",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/Getting-Started.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",next:{title:"Installation",permalink:"/FLAML/docs/Installation"}},u=[{value:"Main Features",id:"main-features",children:[],level:3},{value:"Quickstart",id:"quickstart",children:[{value:"Task-oriented AutoML",id:"task-oriented-automl",children:[],level:4},{value:"Tune user-defined function",id:"tune-user-defined-function",children:[],level:4}],level:3},{value:"Where to Go Next?",id:"where-to-go-next",children:[],level:3}],m={toc:u};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"FLAML is a lightweight Python library that finds accurate machine\nlearning models automatically, efficiently and economically. It frees users from selecting learners and hyperparameters for each learner."),(0,i.kt)("h3",{id:"main-features"},"Main Features"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"For common machine learning tasks like classification and regression, it quickly finds quality models for user-provided data with low computational resources. It supports both classifcal machine learning models and deep neural networks.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"It is easy to customize or extend. Users can find their desired customizability from a smooth range: minimal customization (computational resource budget), medium customization (e.g., scikit-style learner, search space and metric), or full customization (arbitrary training and evaluation code). Users can customize only when and what they need to, and leave the rest to the library.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"It supports fast and economical automatic tuning, capable of handling large search space with heterogeneous evaluation cost and complex constraints/guidance/early stopping. FLAML is powered by a new, ",(0,i.kt)("a",{parentName:"p",href:"Use-Cases/Tune-User-Defined-Function#hyperparameter-optimization-algorithm"},"cost-effective\nhyperparameter optimization"),"\nand learner selection method invented by Microsoft Research."))),(0,i.kt)("h3",{id:"quickstart"},"Quickstart"),(0,i.kt)("p",null,"Install FLAML from pip: ",(0,i.kt)("inlineCode",{parentName:"p"},"pip install flaml"),". Find more options in ",(0,i.kt)("a",{parentName:"p",href:"Installation"},"Installation"),"."),(0,i.kt)("p",null,"There are two ways of using flaml:"),(0,i.kt)("h4",{id:"task-oriented-automl"},(0,i.kt)("a",{parentName:"h4",href:"Use-Cases/task-oriented-automl"},"Task-oriented AutoML")),(0,i.kt)("p",null,"For example, with three lines of code, you can start using this economical and fast AutoML engine as a scikit-learn style estimator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from flaml import AutoML\nautoml = AutoML()\nautoml.fit(X_train, y_train, task="classification")\n')),(0,i.kt)("p",null,"It automatically tunes the hyperparameters and selects the best model from default learners such as LightGBM, XGBoost, random forest etc. ",(0,i.kt)("a",{parentName:"p",href:"Use-Cases/task-oriented-automl#customize-automlfit"},"Customizing")," the optimization metrics, learners and search spaces etc. is very easy. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'automl.add_learner("mylgbm", MyLGBMEstimator)\nautoml.fit(X_train, y_train, task="classification", metric=custom_metric, estimator_list=["mylgbm"])\n')),(0,i.kt)("h4",{id:"tune-user-defined-function"},(0,i.kt)("a",{parentName:"h4",href:"Use-Cases/Tune-User-Defined-Function"},"Tune user-defined function")),(0,i.kt)("p",null,"You can run generic hyperparameter tuning for a custom function (machine learning or beyond). For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from flaml import tune\nfrom flaml.model import LGBMEstimator\n\ndef train_lgbm(config: dict) -> dict:\n    # convert config dict to lgbm params\n    params = LGBMEstimator(**config).params\n    # train the model\n    train_set = lightgbm.Dataset(csv_file_name)\n    model = lightgbm.train(params, train_set)\n    # evaluate the model\n    pred = model.predict(X_test)\n    mse = mean_squared_error(y_test, pred)\n    # return eval results as a dictionary\n    return {"mse": mse}\n\n# load a built-in search space from flaml\nflaml_lgbm_search_space = LGBMEstimator.search_space(X_train.shape)\n# specify the search space as a dict from hp name to domain; you can define your own search space same way\nconfig_search_space = {hp: space["domain"] for hp, space in flaml_lgbm_search_space.items()}\n# give guidance about hp values corresponding to low training cost, i.e., {"n_estimators": 4, "num_leaves": 4}\nlow_cost_partial_config = {\n    hp: space["low_cost_init_value"]\n    for hp, space in flaml_lgbm_search_space.items()\n    if "low_cost_init_value" in space\n}\n# run the tuning, minimizing mse, with total time budget 3 seconds\nanalysis = tune.run(\n    train_lgbm, metric="mse", mode="min", config=config_search_space,\n    low_cost_partial_config=low_cost_partial_config, time_budget_s=3, num_samples=-1,\n)\n')),(0,i.kt)("p",null,"Please see this ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/microsoft/FLAML/blob/main/test/tune_example.py"},"script")," for the complete version of the above example."),(0,i.kt)("h3",{id:"where-to-go-next"},"Where to Go Next?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Understand the use cases for ",(0,i.kt)("a",{parentName:"li",href:"Use-Cases/task-oriented-automl"},"Task-oriented AutoML")," and ",(0,i.kt)("a",{parentName:"li",href:"Use-Cases/Tune-User-Defined-Function"},"Tune user-defined function"),"."),(0,i.kt)("li",{parentName:"ul"},'Find code examples under "Examples": from ',(0,i.kt)("a",{parentName:"li",href:"Examples/AutoML-Classification"},"AutoML - Classification")," to ",(0,i.kt)("a",{parentName:"li",href:"Examples/Tune-PyTorch"},"Tune - PyTorch"),"."),(0,i.kt)("li",{parentName:"ul"},"Watch ",(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/channel/UCfU0zfFXHXdAd5x-WvFBk5A"},"video tutorials"),"."),(0,i.kt)("li",{parentName:"ul"},"Learn about ",(0,i.kt)("a",{parentName:"li",href:"Research"},"research")," around FLAML."),(0,i.kt)("li",{parentName:"ul"},"Refer to ",(0,i.kt)("a",{parentName:"li",href:"reference/automl"},"SDK")," and ",(0,i.kt)("a",{parentName:"li",href:"FAQ"},"FAQ"),".")),(0,i.kt)("p",null,"If you like our project, please give it a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/microsoft/FLAML/stargazers"},"star")," on GitHub. If you are interested in contributing, please read ",(0,i.kt)("a",{parentName:"p",href:"Contribute"},"Contributor's Guide"),"."))}p.isMDXComponent=!0}}]);